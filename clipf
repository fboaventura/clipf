#!/usr/bin/python

import sys, os, cmd, datetime, shlex,re
from getopt import getopt
from os.path import expanduser
import readline
import readline, imp

opts,args = getopt(sys.argv[1:],'h',['help'])
opts=dict(opts)
if '-h' in opts or '--help' in opts:
    print """ Usage %s [-h | --help] [<conf_path>]
    <conf_path> default to ~/.clipf/
    """ % sys.argv[0]
    sys.exit(0)
confpath=expanduser(args and args[0] or '~/.clipf/')
if confpath[-1]!='/':
    confpath+='/'
if not os.access(confpath,os.F_OK):
    print "config don't exists, creating...",
    os.mkdir(confpath)
    dbpath=confpath+'db/'
    os.mkdir(dbpath)
    open(dbpath+'op','w').close()
    open(dbpath+'prod','w').close()

    cf=open(confpath+'clipf.conf','w')
    cf.write("""
# clim configuration

acc='00'
max_lines=40
prompt="\033[31m%(date)s:%(acc)s> \033[0m"

fmts={
    'prod':'\033[34;1m%%(%s)-10.10s\033[0m',
    'prod_code':'\033[34;1m%%(%s)-10.10s\033[0m',
    'prod_code_full':'\033[34;1m%%(%s)-10s\033[0m',
    'acc_id':'\033[35;1m%%(%s)-10.10s\033[0m',
    'prod_name':'\033[36m%%(%s)-16s\033[0m',
    'note':'\033[36m%%(%s)-16s\033[0m',
    'amount':'\033[37m%%(%s)8.2f\033[0m',
    'date':'\033[0m%%(%s)s',
    'header':'\033[34;1m',
    'param':'\033[35;1m%%(%s)s\033[0m',
    }
aliases=[
        'oo :op add ',
        'ol:op ls',
        'pl:prod ls',
        'o :op ',
        'p :prod ',
        'r :rep '
        ]
    """)
    cf.close()
    print "Done"
config = imp.load_source('config',confpath+'clipf.conf')


spln='\033[34m--------------------------------------\033[0m'

class myerr(Exception): pass

def check(cond, msg):
    if not cond:
        raise myerr(msg)

class Rec(object):
    def __init__(self,**kwargs):
        self.__dict__.update(**kwargs)

dt=datetime.date.today().isoformat()
opt=Rec(
        date=dt,
        date_from=dt,
        date_to=dt,
        acc=config.acc,
        max_lines=config.max_lines
        )

class App(cmd.Cmd):
    prompt="$>"
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.term_enc=sys.stdin.encoding
        self.db_enc='UTF-8'
        if not self.term_enc:
            self.term_enc='UTF-8'
        # load prod list
        self.db=confpath+'db/'
        self.prodfmt=u"%(prod)s:%(dc)d:%(name)s\n"
        self.opfmt=u"%(date)s:%(acc)s:%(prod)s:%(amount).2f:%(dc)d:%(note)s\n"
        flds=('prod','dc','name')
        f=open(self.db+'prod','r')
        prodd={}
        for ln in f:
            rr=ln.decode(self.db_enc).rstrip('\n').split(':')
            r=Rec(prod=rr[0],dc=int(rr[1]),name=rr[2])
            grp=r.prod.rstrip('.')
            try:
                pp=grp.rindex('.')
                grp=grp[:pp+1]
            except ValueError:
                grp=''
            r.grp=grp
            prodd[r.prod]=r
        f.close()
        self.prodd=prodd
        self.fmts=config.fmts
        self.aliases=dict([alias.decode(self.db_enc).split(':') for alias in config.aliases])
        self.setPrompt()
    def setPrompt(self):
        self.prompt=config.prompt % opt.__dict__
    def precmd(self,line):
        line=line.decode(self.term_enc)
        for key in self.aliases.iterkeys():
            if line.startswith(key):
                line=self.aliases[key]+line[len(key):]
        return line.encode(self.term_enc)
    def preloop(self):
        print """Personal finance accounting in command line.
Type "help" for list of available commands. Type "help <command>" for help about particular command."""
    def _fx(self,m):
        m=m.group(1)
        if ':' in m:
            fn,dt = m.split(':')
        else:
            dt,fn=m,m
        return self.fmts[dt] % fn
    def ffmt(self,fmt):
        pat=re.compile(r"\$\(([a-z_:]+)\)")
        return re.sub(pat,self._fx,fmt).replace('[[',self.fmts['header']).replace(']]','\033[0m')
    def gen_completions(self,text):
        s=readline.get_line_buffer().decode(self.term_enc)
        grp=s and (s[-1]!=' ') and s.split()[-1] or ''
        pp=grp.rfind('.')
        if pp==-1:
            prod_group=''
        else:
            prod_group=grp[:pp+1]
        grplen=len(prod_group)
        data=[r.prod[grplen:] for r in self.prodd.itervalues() 
                if r.prod.startswith(grp) and r.grp==prod_group]
        data=[ itm[-1]!='.' and itm+' ' or itm for itm in data]
        data.sort()
        data=[item.encode(self.term_enc) for item in data]
        return data

    def complete(self,text,state):
        if state==0:
            self.completions=self.gen_completions(text)+[None]
        return self.completions[state]
    def select(self,dfrom=''):
        flds=('date','acc','prod','amount','dc','note')
        f=open(self.db+'op','r')
        for ln in f:
            if ln>=dfrom:
                rr=ln.decode(self.db_enc).rstrip('\n').split(':')
                yield Rec(date=rr[0],acc=rr[1],prod=rr[2],amount=float(rr[3]),dc=int(rr[4]),note=rr[5])
        f.close()
    def dest(self,lst):
        if len(lst)>int(opt.max_lines) and self.interactive:
            return os.popen('less','w')
        else:
            return None
    def _cmd(self,cmd,c,usage):
        try:
            cl=[s.decode(self.term_enc) for s in shlex.split(c)]
            check(len(cl),usage)
            cc=cl[0]
            meth=getattr(self,'_%s_%s' % (cmd, cc))
            meth(cl[1:])
        except AttributeError:
            print usage
            raise
        except myerr, e:
            print e
            raise
        return 0

    def do_prod(self,c):
        self._cmd('prod',c,"Usage: prod ( ls | add | rm ) <args>")
    def help_prod(self):
        print """ Usage: prod <subcommand> [options] [<args>] 
    Subcommands:
        add [-d] <item_code> <item_name> 
            - add new item. '-d' option mark item as income
              Type <item_name> in quotes, if it contain spaces
        rm <item_code_pattern>
            - remove all items, which code starts with <item_code_pattern>
        ls [<item_code>]
            - list all items in <item_code> group
          """
    def do_op(self,c):
        self._cmd('op',c,"Usage: op ( ls | add ) <args>")
    def help_op(self):
        print """ Usage: op <subcommand> [<options>] <args>
    Subcommands:
        add [-d <date>] [-a <account>] <item_code> <amount> [<note>]
            - add new operation.
                '-d' - override operation date to <date> (see 'help set' for details)
                '-a' - override operation account to <account> (see 'set' for details)
              the income/expense flag for operation would be taken from item 
              type <note> in quotes, if it contain spaces
        ls [<item_code_pattern>]
            - show list of operations for the default reporting period (see 'help set' for details)
              if <item_code_pattern> specified, show only operations with items, which code starts with pattern
    Note:
        There is no delete command for operation. You need to add the same operation with negative amount
        to revoke operation.
            """

    def do_rep(self,c):
        self._cmd('rep',c,"Usage: rep ( prod | acc )")
    def help_rep(self):
        print """ Usage: rep <subcommand> [<args>]
    Subcommands:
        prod [<item_code>]
            - show turnover report with total turnover by each subling of <item_code> item group. 
              Default by root group.
        acc
            - show turnover and remains by each account
        """

    def _rep_prod(self,args):
        prod_group=args and args[0] or ''
        dt,ct = 0.0, 0.0
        grplen=len(prod_group)
        groups={}
        for r in self.select(dfrom=opt.date_from):
            if r.prod.startswith(prod_group) and r.date<=opt.date_to and r.acc==opt.acc:
                prod=r.prod[grplen:]
                pp=prod.find('.')
                if pp==-1:
                    grp=prod
                else:
                    grp=prod[:pp+1]
                rr=groups.get(grp,None)
                if not rr:
                    rr=Rec(prod=grp,dt=0.0,ct=0.0)
                    groups[grp]=rr
                rr.dt+=r.amount*r.dc #income
                rr.ct+=r.amount*(1-r.dc) #expense
        data=groups.values()
        data.sort(key=lambda rr:rr.prod)
        dest=self.dest(data)
        fmt=self.ffmt("$(prod)  $(dt:amount)  $(ct:amount)  %(per)4.1f%%  $(prod_name)")
        try:
            print >>dest, self.ffmt("[[ Report by product. Period from $(date_from:param)[[ to $(date_to:param)]]") % opt.__dict__
            if prod_group:
                print >>dest, self.ffmt("[[ Product group: $(group:param)]]") % {'group':prod_group}
            print >>dest, spln
            tot=sum([dd.ct for dd in data])
            for dd in data:
                dt+=dd.dt
                ct+=dd.ct
                dd.per=dd.ct*100/tot
                prod=self.prodd.get(prod_group+dd.prod,None)
                dd.prod_name=prod and prod.name or "code not in list"
                print >>dest, fmt % dd.__dict__
            print >>dest, spln
            print >>dest, self.ffmt("[[Totals:]]     %8.2f  %8.2f") % (dt,ct)
        except IOError:
            pass
               
    def _rep_acc(self,args):
        rb, dt,ct = 0.0, 0.0, 0.0
        data={}
        for r in self.select():
            rr=data.get(r.acc,None)
            if not rr:
                rr=Rec(acc=r.acc,rest=0.0,dt=0.0,ct=0.0)
                data[r.acc]=rr
            if r.date<opt.date_from:
                rr.rest+=r.amount*(2*r.dc-1)
            elif r.date<=opt.date_to:
                rr.dt+=r.amount*r.dc
                rr.ct+=r.amount*(1-r.dc)
        data=data.values()
        data.sort(key=lambda r:r.acc)
        dest=self.dest(data)
        try:
            print >>dest, self.ffmt("[[Report by accounts. Period from $(date_from:param) [[to $(date_to:param)]]") % opt.__dict__
            print >>dest, spln
            fmt=self.ffmt("$(acc:acc_id)  $(rest:amount)  $(dt:amount)  $(ct:amount)  $(re:amount)")
            for dd in data:
                dd.re=dd.rest+dd.dt-dd.ct
                rb+=dd.rest
                dt+=dd.dt
                ct+=dd.ct
                print >>dest, fmt % dd.__dict__
            print >>dest, spln
            print >>dest, self.ffmt("[[Totals:]]     %8.2f  %8.2f  %8.2f  %8.2f") % (rb,dt,ct,rb+dt-ct)
        except IOError:
            pass


    def _prod_ls(self,args):
        prod_group=args and args[0] or ''
        grplen=len(prod_group)
        data=[Rec(**r.__dict__) for r in self.prodd.itervalues() if r.grp==prod_group]
        for r in data:
            r.prod=r.prod[grplen:]
        data.sort(key=lambda k:k.prod)
        dest=self.dest(data)
        fmt=self.ffmt("$(prod)  %(dc)d  $(name:prod_name)")
        try:
            print >>dest, self.ffmt("[[Product list. Group: $(group:param)]]") % {'group':prod_group}
            print >>dest, spln
            for r in data:
                print >>dest, fmt % r.__dict__
        except IOError:
            pass
    def saveProds(self):
        f=open(self.db+'prod.tmp','w')
        for prod in self.prodd.itervalues():
            rr=self.prodfmt % prod.__dict__
            f.write(rr.encode(self.db_enc))
        f.close()
        os.remove(self.db+'prod')
        os.rename(self.db+'prod.tmp', self.db+'prod')

    def _prod_add(self,args):
        usage="Usage: prod add [-d] <prod_code> <prod_name>"
        ops,args = getopt(args,'d')
        check(len(args)==2, usage)
        ops=dict(ops)
        if '-d' in ops:
            dc=1
        else:
            dc=0
        prod_code=args[0]
        group=prod_code.rstrip('.')
        pp=group.rfind('.')
        if pp==-1:
            group=''
        else:
            group=group[:pp+1]
        chk=self.prodd.get(group,None)
        check(chk or (group==''), "Product group %s don't exists" % group)
        args=Rec(prod=prod_code,grp=group,name=args[1],dc=dc)
        self.prodd[prod_code]=args
        f=open(self.db+'prod','a')
        rr=self.prodfmt % args.__dict__
        f.write(rr.encode(self.term_enc))
        f.close()
        print "Product %s added" % args.prod
    def _prod_dump(self,args):
        sql="""select prod_code,prod_name,dt from prod order by prod_code"""
        for r in self.select_d(sql):
            r['dtopt']=r['dt']==1 and '-d' or ''
            print "prod add %(dtopt)s %(prod_code)s '%(prod_name)s'" % r
    def _prod_rm(self,args):
        usage="prod del <prod_code>"
        check(len(args)==1, usage)
        data=[prod for prod in self.prodd.iterkeys() if prod.startswith(args[0])]
        for prod in data:
            del self.prodd[prod]
            print "Product %s deleted." % prod
        self.saveProds()
    def _op_ls(self,args):
        fmt=self.ffmt('$(date)  $(acc:acc_id)  $(amount)  $(prod:prod_code_full)  $(note)')
        prod_code=args and args[0] or ''
        dt, ct = 0.0, 0.0
        data=[r for r in self.select(dfrom=opt.date_from) 
                if r.date<=opt.date_to and r.prod.startswith(prod_code)]
        data.sort(key=lambda x:(x.date,x.acc))
        dest=self.dest(data)
        try:
            print >>dest, self.ffmt("[[Operations]]")
            print >>dest, spln
            for d in data:
                dt+=d.amount*d.dc
                ct+=d.amount*(1-d.dc)
                print >>dest, fmt % d.__dict__
            print >>dest, spln
            print >>dest, self.ffmt("[[Totals: dt=]]%.2f  [[ct=]]%.2f") %(dt,ct)
        except IOError:
            pass
    def _op_dump(self,args):
        sql="""select op_date,acc_id,prod_code,amount,note
            from op
            where op_date between '%(date_from)s' and '%(date_to)s'
            """ % self.opt
        for r in self.select_d(sql):
            print "op add -d %(op_date)s -a %(acc_id)s %(prod_code)s %(amount).2f '%(note)s'" % r
    def _op_add(self,args):
        usage="Usage: op add [-d <op_date>] [-a acc] <prod_code> <amount> [note]"
        ops,args = getopt(args,'a:d:')
        check(len(args)>1,usage)
        ops=dict(ops)
        prod=self.prodd.get(args[0],None)
        check(prod,'No such product code: %s' % args[0])
        if len(args)>2:
            note=args[2]
        else:
            note=''
        dd=Rec(
            acc= ops.get('-a',opt.acc),
            date= ops.get('-d',opt.date),
            prod= prod.prod,
            amount= float(args[1]),
            dc=prod.dc,
            note= note)
        f=open(self.db+'op','a')
        rr=self.opfmt % dd.__dict__
        f.write(rr.encode(self.db_enc))
        f.close()
    def do_show(self,c):
        usage="Usage: show [<option_name>]"
        cl=c.split()
        opts=opt.__dict__.keys()
        if cl:
            opts=cl
        for o in opts:
            if o[0]!='_':
                if o in opt.__dict__:
                    print "%s = %s" % (o, getattr(opt,o))
                else:
                    print "Unknown option:%s" % o
    def help_show(self):
        print """ Usage: show [<option>]
        Show current option settings (all or for <option> only)
        """
    def do_set(self,c):
        usage="Usage: set <option> <value>"
        cl=shlex.split(c)
        if len(cl)==2:
            # set option value
            if cl[0] in opt.__dict__:
                opt.__dict__[cl[0]]=cl[1]
            else:
                print "Unknown option: %s" % cl[0]
        else:
            print usage
        self.setPrompt()
    def help_set(self):
        print """ Usage: set <option> <value>
    Possible options:
        date - default date for new operation.
        date_from, date_to - period for all reports and operation list (op ls).
        acc - default account for new operation.
        max_lines - use console viewer (less) if report output exceed this number of lines.
    Note:
        Enter all dates in YYYY-MM-DD format.
        """

    def do_quit(self,c):
        return 1
    do_q=do_quit
    def help_quit(self):
        print "Quit the program."

def run():
    app=App()
    app.interactive=sys.stdin.isatty()
    if app.interactive:
        readline.parse_and_bind("tab: complete")
        readline.set_completer_delims(' .')
        readline.set_completer(app.complete)
        app.cmdloop()
    else:
        for ln in sys.stdin:
            app.onecmd(ln)

if __name__=='__main__':
    run()
